# Goal: 
Arbitrary code execution

# Primitives
- The enviorenment variables. The program has a GNU_STACK segment, and a LOAD segment.
    *  The problem? Env vars are string by implementation. This means a few things:
        + We can't include characters like `\x00`, since that would end the env var
        + Every single byte we write is interpreted as a string. So when I write "0xdeadbeef" inside an env var, It becomes a pointer to "0xdeadbeef".
            + *Note*: This might be a positive, for getting /bin/sh into ebx, seeing as we have not data sections, and ASLR is active.

No matter how long i think about it, We can only call a single gadget. There's also a pointer to a syscall in the stack. This means that so long as we can get ESP to point to it during a ret, we can also act as if we had a syscall primitive. 

If we want to have at least 0xb argv vars, 
and also want to pop /bin/sh to ebx
and also want the ret of that pop gadget to be `syscall`

0x30



- arbitrary call instruction to any location we have a pointer to.

# Program flow: 
- It starts by popping what will be our enviorenment variables (technically eax should be the program name, but we have a way of changing it to whatever we want)
- then we have another sequence of instructions, that's logically equivalent to:
    * arbitrary call instruction to any location we have a pointer to.

# Approach one:

My first approach was to try and use the ELF auxillary pointer in the stack to get a syscall gadget. So:

- pivot `esp` to `/bin/sh`
- pop ebx
- in such a way that `ret` will `jmp [ESP]` when `esp` is the syscall gadget

... But the only `add esp` we have that pops `ebx` is `add esp, 0x14`, which isn't enough since we still have to set `eax=0xC` (and we do this by populating `argv` with 11 args, which moves the stack)
... 

I've searched the binary tens of times for logically equivalent gadgets but found nothing. I decided then, that relying on this pointer on the stack might not be the intended solution, seeing as `tiny_hard` which supposedly should be solved the same way, moves `ESP` 0x1000 up anyways.


# Approach Two:

`
x/3i 0xF77047DA
0xf77047da <__vdso_clock_gettime+314>:       mov    ebx,DWORD PTR [ebp+0x8]
0xf77047dd <__vdso_clock_gettime+317>:       call   0xf7704b50 <__kernel_vsyscall>
0xf77047e2 <__vdso_clock_gettime+322>:       mov    ebx,edx
`

This allows us to put /bin/sh to ebx and then calls a function that calls a syscall!!! If we control EAX with the argv pop, we could get execve("/bin/sh",0,0)

... But `EBP` is not set. Fuck.

`EBP` is set at the start of the `__vdso_clock_gettime`, so after some digging around I found a control flow which leads us back to the gadgets I was interest in, we just need to make sure some argv arguments are set in such a way `jmp`s are triggered.

`
loc_7D1:
mov     ecx, esi
mov     eax, 109h
mov     edx, ebx
mov     ebx, [ebp+arg_0]
call    __kernel_vsyscall
`

Unfortunately, as you can see, `eax` is set here. So even though we will be able to get `ebx` to have `/bin/sh`, and we get a `syscall`, we still don't get an `execve`...





# Misc notes:

- 


