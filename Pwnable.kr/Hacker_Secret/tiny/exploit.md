# Goal: 
Arbitrary code execution

# Primitives
- The enviorenment variables. The program has a GNU_STACK segment, and a LOAD segment.
    *  The problem? Env vars are string by implementation. This means a few things:
        + We can't include characters like `\x00`, since that would end the env var
        + Every single byte we write is interpreted as a string. So when I write "0xdeadbeef" inside an env var, It becomes a pointer to "0xdeadbeef".
            + *Note*: This might be a positive, for getting /bin/sh into ebx, seeing as we have not data sections, and ASLR is active.

No matter how long i think about it, We can only call a single gadget. There's also a pointer to a syscall in the stack. This means that so long as we can get ESP to point to it during a ret, we can also act as if we had a syscall primitive. 

If we want to have at least 0xb argv vars, 
and also want to pop /bin/sh to ebx
and also want the ret of that pop gadget to be `syscall`

0x30



- arbitrary call instruction to any location we have a pointer to.

# Program flow: 
- It starts by popping what will be our enviorenment variables (technically eax should be the program name, but we have a way of changing it to whatever we want)
- then we have another sequence of instructions, that's logically equivalent to:
    * arbitrary call instruction to any location we have a pointer to.

# Approach:

- Get the env vars to look like this:
    * \[0x0b, PADDING, /bin/sh, pop_something_ebx_ret,   ]  i planned on somehow going back to `0x08048075` in order to get something equivalent to a ROP chain, but upon more thought i realized we would need to get that value in there... Take a look with gdb.



# Misc notes:

- 



