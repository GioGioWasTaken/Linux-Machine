# Goal: 

# Primitives
- Libc is leaked rightaway
-  we can redirect control flow once, but only once, and not by means of an arbitrary write.

# Approach:

This sounded like a classic one_gadget problem, seeing as (at least upon first sight) we don't have a way of making an actual chain.

I did not see a way to satisfy it seeing as we have very limited control over the program (we get one arbitrary execution), so i tried to figure out a way we could still execute `system`. I instantly tried looking for ways to chain gadgets, and the only way to do this is to use our first arbitrary call to call a location that's greater or equal to the the location of the arbitrary call.


I figured out that by calling the call instruction right away, we can avoid `0xdeadbeef`, an invalid memory address, being pushed to the stack, and instead work with the value the `call` instruction will push. Which is the next instruction:

`
gdb-peda$ x/1i 0x08048585
0x8048585 <main+100>:        add    esp,0x10
gdb-peda$ x/1xw 0x08048585
0x8048585 <main+100>:   0x9010c483
gdb-peda$ x/s 0x08048585
0x8048585 <main+100>:   "\203\304\020\220\213E\364e3\005\024"
`
This is readble memory, therefore it can be interpreted as a pointer to a string. Looking at the `.text` as if it stored a string shows us its raw bytes. I will use these as a `symlink` to `/bin/sh`

oh shit wait, i can't modify `eax` if all i do is `call eax` twice. I'm so dumb lmao.

I will still remain with this approach, of trying to find a readable memory address, and using it as a string which i will combine with `ln -s`. 


```bash
objdump -M intel -d "libc32_pwnable.so" | grep system -B5 
```

Let's find us some calls to system , that are prefaced with some sort of stack pivot


# Misc notes:

- 



