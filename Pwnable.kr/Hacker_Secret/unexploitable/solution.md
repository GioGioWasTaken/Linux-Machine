# Primitives:

- a write of 1295 bytes

# restrictions:

- NX
- ASLR

# Gadgets available:

Control over RBP and RBX


# First Approach: 

At first, I tried finding any gadgets that use direct memory locations with [], so that they dereference my address for me, indirectly giving me control to that address, without a leak.  But none of the gadgets available to me gave me this.

# Second Approach

Then, upon some googling,  I discovered SROP. We can control the RAX value indirectly, since it holds the amount of characters read by read(). Which means, we can trigger SROP by utilizing this in combination with a syscall gadget.

```C
#include <stdio.h>
void main(){
	// no brute forcing
	sleep(3);
	int buf[4];
	read(0, buf, 1295);
}

```

- Ctrl_register: 
	- We will be using SROP. We don't have any way to control RAX directly, so instead we will use the fact read modifies it (since it stores its return value). 
	- payload = padding + addr(main) + addr(syscall) + SignalFrame
	- We provide read with 15 chars, and then it will return to the syscall gadget and trigger a signal interrupt.

- Exploit:
	*  Ctrl_register, set them for a read call to a data/ bss section address, and write /bin/sh there.
	*  Ctrl_register, set them for an execve.


Inside the binary I described it as:

- full exploit:
	* Phase 1:
		 + use the first read() to set the stack for a sigreturn
		 + as part of this, after main() is called again, we enter an input of length 0xf 
		 + We pivot the stack to bss with the sigFrame1
		 + we make a read() syscall on the pivoted stack
	* Phase 2: 
		 + we write payload 2 to bss, which will implant a /bin/sh at a known location, and redirect program flow to one last read()
		 + We use this read to send another 0xf chars, setting another sigreturn frame
		 + syscall triggers the sigreturn, and the sigreturn modifies the registers for an execve syscall, setting RIP to a syscall again.


But this doesn't work, because the syscall gadget i had was just syscall followed by code, and not syscall; ret.... So when calling my read, the program continued execution , which caused a segfault even though I was able to control the registers.

For this to work, we need to do this in one SROP, in other words call execve right away.

# Third approach

1. use ret2csu in order to control the parameters of a read. Write /bin/sh to memory in the bss section.
2. Use a sigret frame in order to make an execve syscall. Point RSI to /bin/sh located in bss.

This works, and we get a shell.
