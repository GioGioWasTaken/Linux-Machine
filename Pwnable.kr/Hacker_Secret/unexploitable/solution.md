# Primitives:

- a write of 1295 bytes

# restrictions:

- NX
- ASLR

# Approach: 

```C
#include <stdio.h>
void main(){
	// no brute forcing
	sleep(3);
	int buf[4];
	read(0, buf, 1295);
}

```

# Constraints :

- NX, ASLR, not bruteforceable

# First Approach : 

Fuck forgot to push from the other computer. The approach is on the remote there...

# Second approach 

## TL;DR 

- Ctrl_register: 
	- We will be using SROP. We don't have any way to control RAX directly, so instead we will use the fact read modifies it (since it stores its return value). 
	- payload = padding + addr(main) + addr(syscall) + SignalFrame
	- We provide read with 15 chars, and then it will return to the syscall gadget and trigger a signal interrupt.

- Exploit:
	*  Ctrl_register, set them for a read call to a data/ bss section address, and write /bin/sh there.
	*  Ctrl_register, set them for an execve.


Inside the binary I described it as:

- full exploit:
	* Phase 1:
		 + use the first read() to set the stack for a sigreturn
		 + as part of this, after main() is called again, we enter an input of length 0xf 
		 + We pivot the stack to bss with the sigFrame1
		 + we make a read() syscall on the pivoted stack
	* Phase 2: 
		 + we write payload 2 to bss, which will implant a /bin/sh at a known location, and redirect program flow to one last read()
		 + We use this read to send another 0xf chars, setting another sigreturn frame
		 + syscall triggers the sigreturn, and the sigreturn modifies the registers for an execve syscall, setting RIP to a syscall again.


But this doesn't work, because the syscall gadget i had was just syscall followed by code, and not syscall; ret.... So when calling my read, the program continued execution , which caused a segfault even though I was able to control the registers.

For this to work, we need to do this in one SROP, in other words call execve right away.

# Third approach

1. use ret2csu in order to control the parameters of a read. Write /bin/sh to memory in the bss section.
2. Use a sigret frame in order to make an execve syscall. Point RSI to /bin/sh located in bss.
