# Goal: 
RCE

# Primitives / Bugs
I have seperated usable bugs(primitives) and other bugs

## Bugs:
1. Segfault when giving the menu no input (0 or -1)
2. p and q get a format string `%d` despite their size being _int16, causing them to overflow into each other at each `scanf` call.
3. After setting a key, we are allowed to use the encrypt and decrypt functions. We cannot set a key and then unset it. `We can set a key, encrypt, and then set a new key.`

## Primitives:

- `RSA_encrypt` has an overflow:
    *  the `encrypted` array has size `256` (still `1024` bytes since it's an `int` array, but the for loop doesn't handle that) while the `sizeCopy` can hold up to `1024 bytes.`
    *  Also, the `sprintf` reads more data then the `s` buffer size, leading to an overflow for any input larger or equal to 642 (642*8=5136), which overwrites the stack canary leading to a stack smashing
        + since the `encrypted` array uses `int`s, all the inputs passed to `s` have 3 zero padded bytes.
    *  To use this, we will first need to figure out how the `encrypt` function works, so that we may get an arbitrary write.
- `RSA_decrypt` has a `FSB`. 

# Approach:

`RSA_encrypt`:

```C

__int64 __fastcall encrypt(unsigned int to_encrypt, unsigned int *public_key)
{
    return mod_exp(to_encrypt, *public_key, public_key[1]);
}
```
which is equivalent to: 

``` C

__int64 __fastcall encrypt(unsigned int to_encrypt, unsigned int *public_key)
{
    return mod_exp(to_encrypt, e, product);
}

```

I wanted to do a ROP chain, but then i realized all my inputs would be zero padded, so i decided to go with a FSB GOT overwrite. 


```C

while ( 2 * actual_len > i )
{
    str_to_cpy[0] = encrypted_data[i + 1];
    str_to_cpy[1] = encrypted_data[i + 2];
    str_to_cpy[2] = 0;
    ptr_to_src = &src[src_i++];             // = (src+src_i)
    __isoc99_sscanf(str_to_cpy, "%02x", ptr_to_src);
    i += 2;
}

```
essentially, this sets up an array src, which is made by treating the string in encrypted_data as raw bytes. So:

`str_to_cpy="41"` will result in 0x41 being written in `src[src_i]`. If i want to write `%d %d %d` to src, i need to write:

`encrypted_data="25 64 20 25 64 20 25 64"` (without spaces of course)



